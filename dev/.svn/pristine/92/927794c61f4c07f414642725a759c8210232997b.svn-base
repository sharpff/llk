/*
 *  Copyright (C) 2008-2015, Marvell International Ltd.
 *  All Rights Reserved.
 */

/*
 * Simple sniffer application
 *
 * Summary:
 *
 * This application configures the Wi-Fi firmware to act as a
 * sniffer. Important information about all the frames received is printed on
 * the console.
 *
 * Description:
 *
 * The application is written using Application Framework that
 * simplifies development of WLAN networking applications.
 *
 * WLAN Initialization:
 *
 * When the application framework is started, it starts up the WLAN
 * sub-system and initializes the network stack. The app receives the event
 * when the WLAN subsystem has been started and initialized.
 *
 * The application starts the sniffer mode of the Wi-Fi module. A sniffer
 * callback is registered that gets called whenever a frame is received from the
 * firmware.
 *
 * The sniffer callback prints important information about the beacon or data
 * packets that are received.
 *
 */

#include <wm_os.h>
#include <app_framework.h>
#include <wmtime.h>
#include <partition.h>
// #include <appln_cb.h>
// #include <appln_dbg.h>
#include <cli.h>
#include <cli_utils.h>
#include <wlan.h>
#include <psm.h>
#include <wmstdio.h>
#include <wmsysinfo.h>
#include <wm_net.h>
#include <httpd.h>
#include <wifidirectutl.h>
#include <nw_utils.h>

#include <lelink/sw/leconfig.h>
#include <lelink/sw/airconfig.h>
#include <lelink/sw/protocol.h>
#include <lelink/sw/state.h>
#include <lelink/sw/io.h>
// test only
#include <lelink/sw/misc.h>


// #define DEBUG_AIRCONFIG

#include <wmlog.h>
#if APPCONFIG_DEBUG_ENABLE
#define dbg(_fmt_, ...)             \
    wmprintf("[appln] "_fmt_"\r\n", ##__VA_ARGS__)
#else
#define dbg(...)
#endif /* APPCONFIG_DEBUG_ENABLE */



static uint8_t gin_airconfig_running;
static uint8_t gin_airconfig_channel_locked;
static uint8_t gin_airconfig_current_channel;
static int gin_airconfig_channel_cared[MAX_CHANNEL_CARE];
struct wlan_network gin_sta_net;


int airconfig_start(void *pc, uint8_t *prov_key, int prov_key_len);
int airconfig_stop();

void inner_set_ap_info(const ap_passport_t *passport);
int inner_start_to_connect_ap(const ap_passport_t *passport);

static int lelink_start();

/*-----------------------Global declarations----------------------*/
int8_t gin_airconfig_ap_connected;
int8_t gin_airconfig_sniffer_got;
char ginSsid[33];

/* This function is defined for handling critical error.
 * For this application, we just stall and do nothing when
 * a critical error occurs.
 *
 */
void appln_critical_error_handler(void *data)
{
	while (1)
		;
	/* do nothing -- stall */
}

void print_frame_info(const wlan_frame_t *frame)
{
	if (frame->frame_type == BEACON) {
		wmprintf("********* Beacon Info *********");
		wmprintf("\r\nType: 0x%x", frame->frame_type);
		wmprintf("\r\nFrame Control flags: 0x%x",
				frame->frame_data.beacon_info.frame_ctrl_flags);
		wmprintf("\r\nSequence Number: %d",
				wlan_get_seq_num(frame->frame_data.
				beacon_info.seq_frag_num));
		wmprintf("\r\nFragmentation Number: %d",
				wlan_get_frag_num(frame->frame_data.
				beacon_info.seq_frag_num));
		snprintf(ginSsid, frame->frame_data.beacon_info.ssid_len + 1,
				"%s", frame->frame_data.beacon_info.ssid);
		wmprintf("\r\nSSID: %s", ginSsid);
		wmprintf("\r\n*******************************\r\n");
	} else if (frame->frame_type == DATA) {
		if (frame->frame_data.data_info.frame_ctrl_flags & 0x01) {
			wmprintf("********* Data Packet Info *********");
			if (frame->frame_data.data_info.frame_ctrl_flags & 0x08)
				wmprintf("\r\nThis is a retransmission\r\n");
			wmprintf("\r\nType: 0x%x", frame->frame_type);
			wmprintf("\r\nFrame Control flags: 0x%x",
				frame->frame_data.data_info.frame_ctrl_flags);
			wmprintf("\r\nBSSID: ");
			print_mac(frame->frame_data.data_info.bssid);
			wmprintf("\r\nSource: ");
			print_mac(frame->frame_data.data_info.src);
			wmprintf("\r\nDestination: ");
			print_mac(frame->frame_data.data_info.dest);
			wmprintf("\r\nSequence Number: %d",
				wlan_get_seq_num(frame->frame_data.
				data_info.seq_frag_num));
			wmprintf("\r\nFragmentation Number: %d",
				wlan_get_frag_num(frame->frame_data.
				data_info.seq_frag_num));
			wmprintf("\r\nQoS Control Flags: 0x%x",
				frame->frame_data.data_info.qos_ctrl);
			wmprintf("\r\n*******************************\r\n");
		}
	}
}


#define AIRCONFIG_INFINITE_INTERVAL os_msec_to_ticks(0xffffffff)
// #define AIRCONFIG_CHANNEL_SWITCH_INTERVAL os_msec_to_ticks(800)
#define AIRCONFIG_CHANNEL_SWITCH_INTERVAL os_msec_to_ticks(300)
#define AIRCONFIG_CHANNEL_TIMEOUT os_msec_to_ticks(12*1000)
#define AIRCONFIG_TIMEOUT os_msec_to_ticks(60*60*1000)
#define LOCK_AIRCONFIG "lock_airconfig"
static os_thread_t thread_airconfig;
static os_thread_t thread_lelink;
static os_timer_t timer_airconfig;
static os_timer_t timer_timeout;
static os_thread_stack_define(thread_stack_airconfig, 1024);
static os_thread_stack_define(thread_stack_lelink, 2048*3);
static os_semaphore_t sem_airconfig;

// static uint16_t g_airconfig_base = 0x0000;
// extern uint8_t gin_ssid_crc;
void native_sniffer_airconfig_processing(const wlan_frame_t *frame, const uint16_t len)
{   
    // uint8_t latest_ssid_crc8 = 0;
    if (frame->frame_type == BEACON) {
        #if 1
        snprintf(ginSsid, frame->frame_data.beacon_info.ssid_len + 1,
            "%s", frame->frame_data.beacon_info.ssid);
        // latest_ssid_crc8 = crc8(ginSsid, strlen(ginSsid));
        // wmprintf("SSID: %s crc[0x%02x-0x%02x]\r\n", ginSsid, latest_ssid_crc8);
        #endif      
    } else  if (frame->frame_type == DATA){
        const uint8_t *tmp_dest;
        const uint8_t *tmp_src;
        const uint8_t *tmp_bssid;
        static uint16_t base = 0;
        static target_item_t item;
        int i = 0;
        tmp_dest = (uint8_t*)frame->frame_data.data_info.dest;
        tmp_bssid = (uint8_t*)frame->frame_data.data_info.bssid;
        tmp_src  = (uint8_t*)frame->frame_data.data_info.src; 
            //wmprintf("frame_type is [0x%x]\r\n", frame->frame_type);
        if (!gin_airconfig_running)
            return;

        if (!gin_airconfig_channel_locked)
        {
#if 0
            wmprintf("********* Data Packet Info *********");
            if (frame->frame_data.data_info.frame_ctrl_flags & 0x08)
                wmprintf("\r\nThis is a retransmission\r\n");
            wmprintf("\r\nType: 0x%x", frame->frame_type);
            wmprintf("\r\nFrame Control flags: 0x%x",
                frame->frame_data.data_info.frame_ctrl_flags);
            wmprintf("\r\nBSSID: ");
            print_mac(frame->frame_data.data_info.bssid);
            wmprintf("\r\nSource: ");
            print_mac(frame->frame_data.data_info.src);
            wmprintf("\r\nDestination: ");
            print_mac(frame->frame_data.data_info.dest);
            wmprintf("\r\nSequence Number: %d",
            wlan_get_seq_num(frame->frame_data.data_info.seq_frag_num));
            wmprintf("\r\nFragmentation Number: %d",
            wlan_get_frag_num(frame->frame_data.data_info.seq_frag_num));
            wmprintf("\r\nQoS Control Flags: 0x%x",
                frame->frame_data.data_info.qos_ctrl);
            wmprintf("\r\n*******************************\r\n");

            /**address#3 is is the destination address*/
            tmp_dest = frame->frame_data.data_info.src;
            /*address #2 is the source address*/
            tmp_src  = frame->frame_data.data_info.bssid;

#endif


            // only multicast
            if (!(0x01 == tmp_dest[0] && 0x00 == tmp_dest[1] && 0x5E == tmp_dest[2])) {
                // only broadcast
                for (i = 0; i < ETH_ALEN; i++) {
                    if (tmp_dest[i] != 0xFF) {
                        return;
                    }
                }
            }

            // if (((tmp_src[0] == 0x58) &&
            //    (tmp_src[1] == 0x20) &&
            //     (tmp_src[2] == 0xb1) &&
            //     (tmp_src[3] == 0x79) &&
            //     (tmp_src[4] == 0xe8) && 
            //     (tmp_src[5] == 0x5f))) {
            //     wmprintf("ch[%d], ieee80211_hdr->TRU:%02X:%02X:%02X:%02X:%02X:%02X--SRC:%02X:%02X:%02X:%02X:%02X:%02X--DST:%02X:%02X:%02X:%02X:%02X:%02X---%d\r\n",
            //         gin_airconfig_current_channel, tmp_bssid[0], tmp_bssid[1], tmp_bssid[2], tmp_bssid[3], tmp_bssid[4], tmp_bssid[5],
            //         tmp_src[0], tmp_src[1], tmp_src[2], tmp_src[3], tmp_src[4], tmp_src[5],
            //         tmp_dest[0], tmp_dest[1], tmp_dest[2], tmp_dest[3], tmp_dest[4], tmp_dest[5],
            //         len
            //     );
            // }

            item.data = len;
            memcpy(item.mac_src, tmp_src, sizeof(item.mac_src));
            memcpy(item.mac_dst, tmp_dest, sizeof(item.mac_dst));
            memcpy(item.mac_bssid, tmp_bssid, sizeof(item.mac_bssid));
            airconfig_nw_state_t state = (airconfig_nw_state_t)airconfig_do_sync(&item, gin_airconfig_current_channel, gin_airconfig_channel_cared, &base);
            switch (state) {
                case AIRCONFIG_NW_STATE_NONE:
                break;
                case AIRCONFIG_NW_STATE_ERROR_PARAM:
                break; 
                case AIRCONFIG_NW_STATE_CHANNEL_LOCKED: {
                    wmprintf("[Prov] state => gin_airconfig_channel_locked \r\n");
                    gin_airconfig_channel_locked = 1;
                    // os_thread_sleep(AIRCONFIG_INFINITE_INTERVAL);
                }break; 
            }
        } else if (0 == memcmp(item.mac_src, tmp_src, sizeof(item.mac_src))) {
            ap_passport_t passport;
            // wmprintf("[Prov] sniffer Channel# [%d] \r\n", gin_airconfig_current_channel);
            int ret = airconfig_get_info(len, base, &passport, ginSsid, strlen(ginSsid));
            // int ret = airconfig_get_info(len, base, &passport, NULL, 0);
            if (ret) {
                APPLOG("ssid[%s] psk[%s] base[%d]\r\n", passport.ssid, passport.psk, base);
                airconfig_stop();
                inner_set_ap_info(&passport);
                gin_airconfig_sniffer_got = 1;
            }
        }
    }
}

static void timer_airconfig_cb(os_timer_arg_t handle)
{
	os_semaphore_put(&sem_airconfig);
}

static void timer_timeout_cb(os_timer_arg_t handle)
{
    airconfig_stop();
    os_timer_deactivate(&timer_timeout);
    os_timer_delete(&timer_timeout);
    wmprintf("timer_timeout_cb \r\n");
}

static void thread_airconfig_proc(os_thread_arg_t thandle)
{

    int ret;
    int channel = 1;
    int do_care = 0;

// struct wlan_network *net;

	ret = os_semaphore_create(&sem_airconfig, "sem_airconfig");
	os_semaphore_get(&sem_airconfig, OS_WAIT_FOREVER);

	ret = os_timer_create(&timer_airconfig, "timer_airconfig",
			      AIRCONFIG_CHANNEL_SWITCH_INTERVAL,
			      timer_airconfig_cb, NULL, OS_TIMER_PERIODIC,
			      OS_TIMER_AUTO_ACTIVATE);

#if 0
	ret = aes_drv_init();
	if (ret != WM_SUCCESS) {
		wmlog_e("Unable to initialize AES engine.\r\n");
		return;
	}
#endif

	wakelock_get(LOCK_AIRCONFIG);

	gin_airconfig_running = 1;
	while (gin_airconfig_running) {
        int i = 0;
        if (gin_airconfig_channel_locked) {
            //os_thread_sleep(AIRCONFIG_CHANNEL_TIMEOUT);
            do_care = 0;
            for (i = 0; i < MAX_CHANNEL_CARE; i++) {
                if (gin_airconfig_channel_cared[i] && channel == gin_airconfig_channel_cared[i]) {
                    do_care = 1;
                    break;
                }
            }
        } else {
            do_care = 1;
        }

        // test only
        // do_care = 1;


        if (do_care) {
            wmprintf("[Prov] sniffer Channel# [%d] \r\n", channel);
            gin_airconfig_current_channel = channel;
            ret = wlan_sniffer_start(0x07, 0x00, channel, native_sniffer_airconfig_processing);
            //ret = wlan_sniffer_start(0x07, 0x00, channel, ezconn_recv);
            if (ret != WM_SUCCESS)
                wmprintf("Error: wlan_sniffer_start failed.");
            //wmprintf("os_semaphore_get s [%d]\r\n", ret);
            os_semaphore_get(&sem_airconfig, OS_WAIT_FOREVER);
            //wmprintf("os_semaphore_get e [%d]\r\n", ret);
            if (gin_airconfig_channel_locked) {
                os_thread_sleep(AIRCONFIG_CHANNEL_TIMEOUT);
                wmprintf("AIRCONFIG_CHANNEL_TIMEOUT for channel[%d] [%d] \r\n", gin_airconfig_channel_cared[i], channel);
                gin_airconfig_channel_cared[i] = 0;
                if (0 == gin_airconfig_sniffer_got) {
                    // state go back to sniffer
                    gin_airconfig_sniffer_got = -1;
                    airconfig_stop();
                }
            }
            wlan_sniffer_stop();
        }

        if (!gin_airconfig_running) {
           break;
        }

        /*              
        if (es.state == I_LINK_CONNECT_PROVISION_DONE) {
        wmprintf("[prov] I_LINK_CONNECT provisioning done.\r\n");
        break;
        }
        */
        channel++;

        if (wlan_get_11d_enable_status()) {
            if (channel == 15)
                channel = 1;
        }
        else if (channel == 12)
            channel = 1;    
    }

    os_timer_deactivate(&timer_airconfig);
    os_timer_delete(&timer_airconfig);

    wakelock_put(LOCK_AIRCONFIG);
    wmprintf("[Prov] sniffer Channel# [%d] finished\r\n", channel);

    os_thread_self_complete((os_thread_t *)thandle);
    
    return;
}

int airconfig_start(void *ptr, uint8_t *prov_key, int prov_key_len)
{
    int ret;
    /*
    if (prov_g.pc != NULL) {
    prov_w("already configured!");
    return -WM_E_PROV_INVALID_CONF;
    }
    

    if (pc == NULL) {
        prov_w("configuration not provided!");
        return -WM_E_PROV_INVALID_CONF;
    }


    if (prov_key_len > 0 && prov_key != NULL) {
        prov_ezconn_set_device_key(prov_key, prov_key_len);
    }


    if (!pc->provisioning_event_handler) {
        prov_w("No event handler specified");
        return -WM_E_PROV_INVALID_CONF;
    }
    */


    //prov_g.pc = pc;
    ret = os_timer_create(&timer_timeout, "timer_timeout",
                  AIRCONFIG_TIMEOUT,
                  timer_timeout_cb, NULL, OS_TIMER_PERIODIC,
                  OS_TIMER_AUTO_ACTIVATE);
    if (ret) {
        APPLOGE("os_timer_create timeout: %d", ret);
        goto fail; 
    }
    ret = os_thread_create(&thread_airconfig,
        "airconfig",
        thread_airconfig_proc,
        (void *)&thread_airconfig,
        &thread_stack_airconfig,
        OS_PRIO_3);
    if (ret) {
        APPLOGE("Failed to launch thread: %d", ret);
        goto fail;
    }
    gin_airconfig_sniffer_got = 0;
    return 1;

fail:
    if (thread_airconfig)
        os_thread_delete(&thread_airconfig);

    return 0;
}

int airconfig_stop()
{
    gin_airconfig_channel_locked = 0;
    gin_airconfig_current_channel = 0;
    gin_airconfig_running = 0;
    airconfig_reset();
    return 0;
}

void inner_set_ap_info(const ap_passport_t *passport) {
    gin_airconfig_ap_connected = 0;
    bzero(&gin_sta_net, sizeof(gin_sta_net));
    /* Set SSID as passed by the user */
    strncpy(gin_sta_net.ssid, passport->ssid, strlen(passport->ssid));
    if (strlen(passport->psk))
        gin_sta_net.security.type = WLAN_SECURITY_WPA2;
    else
        gin_sta_net.security.type = WLAN_SECURITY_NONE;
    /* Set the passphrase */
    strncpy(gin_sta_net.security.psk, passport->psk, strlen(passport->psk));
    gin_sta_net.security.psk_len = strlen(gin_sta_net.security.psk);
    /* Set profile name */
    strcpy(gin_sta_net.name, "sta-network");
    /* Set channel selection to auto (0) */
    gin_sta_net.channel = 0;
    /* Set network type to STA */
    gin_sta_net.type = WLAN_BSS_TYPE_STA;
    /* Set network role to STA */
    gin_sta_net.role = WLAN_BSS_ROLE_STA;
    /* Specify address type as dynamic assignment */
    gin_sta_net.ip.ipv4.addr_type = ADDR_TYPE_DHCP;
}

static void thread_lelink_proc(os_thread_arg_t thandle) {

    void *ctx_r2r = (void *)lelinkNwNew(REMOTE_IP, REMOTE_PORT, 0, 0);
    void *ctx_q2a = (void *)lelinkNwNew(NULL, 0, NW_SELF_PORT, ctx_r2r);
    // int i, ret = 0;


    while (1) {
        lelinkPollingState(1000, ctx_r2r, ctx_q2a);
        lelinkDoPollingQ2A(ctx_q2a);
        // share the QA queue to handle the remote ctrl
        lelinkDoPollingR2R(ctx_r2r);
        // LELOG("thread_airconfig_proc pollingState ret [%d]", ret);
    }

    lelinkNwDelete(ctx_r2r);
    lelinkNwDelete(ctx_q2a);
    os_thread_self_complete((os_thread_t *)thandle);
}

static int lelink_start(void) {
    int ret;
    ret = os_thread_create(&thread_lelink,
        "lelink",
        thread_lelink_proc,
        (void *)&thread_lelink,
        &thread_stack_lelink,
        OS_PRIO_3);
    if (ret) {
        APPLOGE("Failed to launch thread: %d", ret);
        goto fail;
    }
    return 1;
fail:
    if (thread_lelink)
        os_thread_delete(&thread_lelink);

    return 0;
}

// static int lelink_stop(void) {
//     os_thread_delete(&thread_lelink);
//     lelinkDeinit();
// }

/** This Sniffer callback is called from a thread with small stack size,
 * So do minimal memory allocations for correct behaviour.
 */
void sniffer_cb(const wlan_frame_t *frame, const uint16_t len)
{
    if (frame) {
        print_frame_info(frame);
    }
}

#ifdef PREGEN_INFO_2_FLASH
int preGenStableInfo2Flash(void) {
#include <lelink/sw/sengine.h>
    int ret = 0;
    AuthCfg authCfg;
    uint8_t mac[6] = {0};
    char macStr[13] = {0};


    const uint8_t ginScript[] = {
0x2d, 0x2d, 0x5b, 0x5b, 0x20, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x0d, 0x0a, 0x09,
0x54, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x0d,
0x0a, 0x20, 0x20, 0x5d, 0x5d, 0x0d, 0x0a, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20,
0x74, 0x61, 0x62, 0x6c, 0x65, 0x54, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x28, 0x20, 0x63,
0x6d, 0x64, 0x20, 0x29, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x72,
0x63, 0x6d, 0x64, 0x20, 0x3d, 0x20, 0x22, 0x22, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c,
0x20, 0x69, 0x0d, 0x0a, 0x09, 0x0d, 0x0a, 0x09, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x3d, 0x31, 0x2c,
0x20, 0x23, 0x63, 0x6d, 0x64, 0x20, 0x64, 0x6f, 0x0d, 0x0a, 0x09, 0x09, 0x73, 0x74, 0x72, 0x63,
0x6d, 0x64, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x63, 0x6d, 0x64, 0x20, 0x2e, 0x2e, 0x20, 0x73,
0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x63, 0x68, 0x61, 0x72, 0x28, 0x63, 0x6d, 0x64, 0x5b, 0x69,
0x5d, 0x29, 0x0d, 0x0a, 0x09, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x09, 0x72, 0x65, 0x74, 0x75, 0x72,
0x6e, 0x20, 0x73, 0x74, 0x72, 0x63, 0x6d, 0x64, 0x0d, 0x0a, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x0d,
0x0a, 0x2d, 0x2d, 0x5b, 0x5b, 0x20, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x0d, 0x0a,
0x09, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65,
0x0d, 0x0a, 0x20, 0x20, 0x5d, 0x5d, 0x0d, 0x0a, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x6f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x28, 0x20,
0x73, 0x74, 0x61, 0x20, 0x29, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x74, 0x61,
0x62, 0x6c, 0x65, 0x73, 0x74, 0x61, 0x20, 0x3d, 0x20, 0x7b, 0x7d, 0x0d, 0x0a, 0x09, 0x6c, 0x6f,
0x63, 0x61, 0x6c, 0x20, 0x69, 0x0d, 0x0a, 0x09, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x3d, 0x31, 0x2c,
0x20, 0x23, 0x73, 0x74, 0x61, 0x20, 0x64, 0x6f, 0x0d, 0x0a, 0x09, 0x09, 0x74, 0x61, 0x62, 0x6c,
0x65, 0x73, 0x74, 0x61, 0x5b, 0x69, 0x5d, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x61, 0x3a, 0x62, 0x79,
0x74, 0x65, 0x28, 0x69, 0x29, 0x0d, 0x0a, 0x09, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x0d, 0x0a, 0x09,
0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x74, 0x61, 0x0d,
0x0a, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x0d, 0x0a, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
0x20, 0x4c, 0x4f, 0x47, 0x54, 0x42, 0x4c, 0x28, 0x74, 0x62, 0x6c, 0x4f, 0x62, 0x6a, 0x29, 0x0d,
0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x72, 0x20, 0x3d, 0x20, 0x22, 0x22,
0x0d, 0x0a, 0x09, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x20, 0x3d, 0x20, 0x31, 0x2c, 0x20, 0x23, 0x74,
0x62, 0x6c, 0x4f, 0x62, 0x6a, 0x20, 0x64, 0x6f, 0x20, 0x0d, 0x0a, 0x09, 0x09, 0x73, 0x74, 0x72,
0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x2e, 0x2e, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66,
0x6f, 0x72, 0x6d, 0x61, 0x74, 0x28, 0x27, 0x25, 0x30, 0x32, 0x78, 0x20, 0x27, 0x2c, 0x20, 0x74,
0x62, 0x6c, 0x4f, 0x62, 0x6a, 0x5b, 0x69, 0x5d, 0x29, 0x0d, 0x0a, 0x09, 0x65, 0x6e, 0x64, 0x0d,
0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x20, 0x28, 0x27, 0x4c, 0x4f, 0x47, 0x54, 0x42, 0x4c,
0x20, 0x27, 0x2e, 0x2e, 0x73, 0x74, 0x72, 0x2e, 0x2e, 0x27, 0x5c, 0x72, 0x5c, 0x6e, 0x27, 0x29,
0x0d, 0x0a, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x0d, 0x0a, 0x2d, 0x2d, 0x5b, 0x5b, 0x20, 0x4d, 0x55,
0x53, 0x54, 0x0d, 0x0a, 0x09, 0x31, 0x2e, 0x20, 0x6a, 0x73, 0x6f, 0x6e, 0x20, 0x3c, 0x2d, 0x3e,
0x20, 0x62, 0x69, 0x6e, 0x0d, 0x0a, 0x09, 0x32, 0x2e, 0x20, 0x6a, 0x73, 0x6f, 0x6e, 0x20, 0x3c,
0x2d, 0x3e, 0x20, 0x6a, 0x73, 0x6f, 0x6e, 0x0d, 0x0a, 0x5d, 0x5d, 0x0d, 0x0a, 0x66, 0x75, 0x6e,
0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x67, 0x65, 0x74, 0x43, 0x76, 0x74, 0x54, 0x79, 0x70, 0x65,
0x28, 0x29, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x77, 0x68, 0x61, 0x74, 0x54,
0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x31, 0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20, 0x62, 0x61, 0x75,
0x64, 0x20, 0x2d, 0x20, 0x64, 0x61, 0x74, 0x61, 0x42, 0x69, 0x74, 0x73, 0x20, 0x70, 0x61, 0x72,
0x69, 0x74, 0x79, 0x28, 0x4e, 0x6f, 0x6e, 0x65, 0x3a, 0x30, 0x2c, 0x20, 0x4f, 0x64, 0x64, 0x3a,
0x31, 0x2c, 0x20, 0x45, 0x76, 0x65, 0x6e, 0x3a, 0x32, 0x29, 0x20, 0x73, 0x74, 0x6f, 0x70, 0x42,
0x69, 0x74, 0x73, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x62, 0x61, 0x75, 0x64,
0x20, 0x3d, 0x20, 0x27, 0x22, 0x39, 0x36, 0x30, 0x30, 0x2d, 0x38, 0x4e, 0x31, 0x22, 0x27, 0x0d,
0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x72, 0x20, 0x3d, 0x20, 0x73, 0x74,
0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x28, 0x27, 0x7b, 0x22, 0x77,
0x68, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x25, 0x64, 0x2c, 0x22, 0x62, 0x61, 0x75,
0x64, 0x22, 0x3a, 0x25, 0x73, 0x7d, 0x27, 0x2c, 0x20, 0x77, 0x68, 0x61, 0x74, 0x54, 0x79, 0x70,
0x65, 0x2c, 0x20, 0x62, 0x61, 0x75, 0x64, 0x29, 0x0d, 0x0a, 0x0d, 0x0a, 0x09, 0x72, 0x65, 0x74,
0x75, 0x72, 0x6e, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x6c, 0x65, 0x6e, 0x28, 0x73,
0x74, 0x72, 0x29, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x0d, 0x0a, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x0d,
0x0a, 0x2d, 0x2d, 0x5b, 0x5b, 0x20, 0x4d, 0x55, 0x53, 0x54, 0x0d, 0x0a, 0x09, 0xe6, 0x9f, 0xa5,
0xe8, 0xaf, 0xa2, 0xe8, 0xae, 0xbe, 0xe5, 0xa4, 0x87, 0xe7, 0x8a, 0xb6, 0xe6, 0x80, 0x81, 0xe3,
0x80, 0x82, 0x0d, 0x0a, 0x0d, 0x0a, 0x09, 0xe6, 0xaf, 0x8f, 0xe4, 0xb8, 0xaa, 0xe8, 0xae, 0xbe,
0xe5, 0xa4, 0x87, 0xe9, 0x83, 0xbd, 0xe7, 0xba, 0xa6, 0xe5, 0xae, 0x9a, 0xe9, 0x9c, 0x80, 0xe8,
0xa6, 0x81, 0xe4, 0xb8, 0x80, 0xe6, 0x9d, 0xa1, 0xe6, 0x88, 0x96, 0xe8, 0x80, 0x85, 0xe5, 0xa4,
0x9a, 0xe6, 0x9d, 0xa1, 0xe6, 0x8c, 0x87, 0xe4, 0xbb, 0xa4, 0xe5, 0x8f, 0xaf, 0xe4, 0xbb, 0xa5,
0xe8, 0x8e, 0xb7, 0xe5, 0x8f, 0x96, 0xe5, 0x88, 0xb0, 0xe8, 0xae, 0xbe, 0xe5, 0xa4, 0x87, 0xe7,
0x9a, 0x84, 0xe6, 0x89, 0x80, 0xe6, 0x9c, 0x89, 0xe7, 0x8a, 0xb6, 0xe6, 0x80, 0x81, 0xe3, 0x80,
0x82, 0x0d, 0x0a, 0x09, 0xe8, 0xbf, 0x94, 0xe5, 0x9b, 0x9e, 0xe7, 0x9a, 0x84, 0xe7, 0x8a, 0xb6,
0xe6, 0x80, 0x81, 0xe7, 0x94, 0xb1, 0xe5, 0x9b, 0xba, 0xe4, 0xbb, 0xb6, 0xe6, 0x9d, 0xa5, 0xe7,
0xbc, 0x93, 0xe5, 0xad, 0x98, 0xe3, 0x80, 0x82, 0x0d, 0x0a, 0x09, 0xe6, 0x8c, 0x87, 0xe4, 0xbb,
0xa4, 0xe5, 0xbf, 0x85, 0xe9, 0xa1, 0xbb, 0xe4, 0xb8, 0xba, 0xe5, 0xae, 0x8c, 0xe6, 0x95, 0xb4,
0xe7, 0x9a, 0x84, 0xe6, 0x8c, 0x87, 0xe4, 0xbb, 0xa4, 0xef, 0xbc, 0x8c, 0xe5, 0x8f, 0xaf, 0xe4,
0xbb, 0xa5, 0xe7, 0x9b, 0xb4, 0xe6, 0x8e, 0xa5, 0xe5, 0xaf, 0xb9, 0xe7, 0x94, 0xb5, 0xe6, 0x8e,
0xa7, 0xe6, 0x9d, 0xbf, 0xe6, 0x93, 0x8d, 0xe4, 0xbd, 0x9c, 0xe7, 0x9a, 0x84, 0xe3, 0x80, 0x82,
0x0d, 0x0a, 0x09, 0xe5, 0x9c, 0xa8, 0xe7, 0x94, 0xa8, 0xe6, 0x88, 0xb7, 0xe5, 0xae, 0x9a, 0xe4,
0xb9, 0x89, 0xe4, 0xba, 0xa7, 0xe5, 0x93, 0x81, 0xe6, 0x97, 0xb6, 0xe5, 0xa1, 0xab, 0xe5, 0x85,
0x85, 0xe3, 0x80, 0x82, 0x0d, 0x0a, 0x0d, 0x0a, 0x09, 0xe6, 0xa0, 0x87, 0xe5, 0x87, 0x86, 0xe6,
0x8e, 0xa5, 0xe5, 0x8f, 0xa3, 0xef, 0xbc, 0x8c, 0xe8, 0xaf, 0xa5, 0xe6, 0x96, 0xb9, 0xe6, 0xb3,
0x95, 0xe7, 0x94, 0xb1, 0xe4, 0xba, 0x91, 0xe7, 0xab, 0xaf, 0xe8, 0x87, 0xaa, 0xe5, 0x8a, 0xa8,
0xe7, 0x94, 0x9f, 0xe6, 0x88, 0x90, 0xe3, 0x80, 0x82, 0x0d, 0x0a, 0x5d, 0x5d, 0x0d, 0x0a, 0x66,
0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x67, 0x65, 0x74, 0x51, 0x75, 0x65, 0x72, 0x69,
0x65, 0x73, 0x28, 0x29, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x71, 0x75, 0x65,
0x72, 0x79, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x63, 0x68, 0x61, 0x72,
0x28, 0x20, 0x30, 0x78, 0x62, 0x62, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x36, 0x2c, 0x20, 0x30, 0x78,
0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2c, 0x20,
0x30, 0x78, 0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x66, 0x61,
0x2c, 0x20, 0x30, 0x78, 0x34, 0x34, 0x20, 0x29, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c,
0x20, 0x71, 0x75, 0x65, 0x72, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x65, 0x6e, 0x20, 0x3d,
0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x63, 0x68, 0x61, 0x72, 0x28, 0x20, 0x30, 0x78,
0x30, 0x39, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30, 0x20, 0x29, 0x0d, 0x0a, 0x0d, 0x0a, 0x09, 0x72,
0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x6c, 0x65, 0x6e,
0x28, 0x20, 0x71, 0x75, 0x65, 0x72, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x65, 0x6e, 0x20,
0x29, 0x2c, 0x20, 0x71, 0x75, 0x65, 0x72, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x65, 0x6e,
0x2c, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x6c, 0x65, 0x6e, 0x28, 0x20, 0x71, 0x75,
0x65, 0x72, 0x79, 0x20, 0x29, 0x2c, 0x20, 0x71, 0x75, 0x65, 0x72, 0x79, 0x0d, 0x0a, 0x65, 0x6e,
0x64, 0x0d, 0x0a, 0x0d, 0x0a, 0x2d, 0x2d, 0x20, 0xe6, 0x9d, 0x9c, 0xe4, 0xba, 0x9a, 0xe7, 0xaa,
0x97, 0xe5, 0xb8, 0x98, 0xe7, 0x94, 0xb5, 0xe6, 0x9c, 0xba, 0x0d, 0x0a, 0x2d, 0x2d, 0x20, 0x62,
0x62, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30,
0x20, 0x30, 0x30, 0x20, 0x66, 0x61, 0x20, 0x34, 0x34, 0x20, 0xe4, 0xb8, 0x8d, 0xe6, 0x98, 0x8e,
0x0d, 0x0a, 0x2d, 0x2d, 0x20, 0x62, 0x62, 0x20, 0x30, 0x31, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30,
0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x66, 0x61, 0x20, 0x34, 0x34, 0x20,
0xe9, 0x80, 0x86, 0xe6, 0x97, 0xb6, 0xe9, 0x92, 0x88, 0x20, 0xe6, 0x9c, 0x89, 0xe7, 0x9b, 0xae,
0xe7, 0x9a, 0x84, 0x0d, 0x0a, 0x2d, 0x2d, 0x20, 0x62, 0x62, 0x20, 0x30, 0x32, 0x20, 0x30, 0x30,
0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x66, 0x61, 0x20,
0x34, 0x34, 0x20, 0xe9, 0xa1, 0xba, 0xe6, 0x97, 0xb6, 0xe9, 0x92, 0x88, 0x20, 0xe6, 0x9c, 0x89,
0xe7, 0x9b, 0xae, 0xe7, 0x9a, 0x84, 0x0d, 0x0a, 0x2d, 0x2d, 0x20, 0x62, 0x62, 0x20, 0x30, 0x35,
0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20,
0x66, 0x61, 0x20, 0x34, 0x34, 0x20, 0xe6, 0xb5, 0x8b, 0xe9, 0x87, 0x8f, 0x0d, 0x0a, 0x2d, 0x2d,
0x20, 0x62, 0x62, 0x20, 0x30, 0x33, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20,
0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x66, 0x61, 0x20, 0x34, 0x34, 0x20, 0xe6, 0x9a, 0x82, 0xe5,
0x81, 0x9c, 0x0d, 0x0a, 0x2d, 0x2d, 0x20, 0x62, 0x62, 0x20, 0x30, 0x36, 0x20, 0x30, 0x30, 0x20,
0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x30, 0x30, 0x20, 0x66, 0x61, 0x20, 0x34,
0x34, 0x20, 0xe7, 0x8a, 0xb6, 0xe6, 0x80, 0x81, 0xe8, 0x8e, 0xb7, 0xe5, 0x8f, 0x96, 0x0d, 0x0a,
0x0d, 0x0a, 0x2d, 0x2d, 0x5b, 0x5b, 0x20, 0x4d, 0x55, 0x53, 0x54, 0x0d, 0x0a, 0x5d, 0x5d, 0x0d,
0x0a, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x76, 0x74, 0x53, 0x74, 0x64,
0x32, 0x50, 0x72, 0x69, 0x28, 0x6a, 0x73, 0x6f, 0x6e, 0x29, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63,
0x61, 0x6c, 0x20, 0x74, 0x62, 0x20, 0x3d, 0x20, 0x63, 0x6a, 0x73, 0x6f, 0x6e, 0x2e, 0x64, 0x65,
0x63, 0x6f, 0x64, 0x65, 0x28, 0x6a, 0x73, 0x6f, 0x6e, 0x29, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63,
0x61, 0x6c, 0x20, 0x63, 0x74, 0x72, 0x6c, 0x20, 0x3d, 0x20, 0x74, 0x62, 0x5b, 0x22, 0x63, 0x74,
0x72, 0x6c, 0x22, 0x5d, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x63, 0x6d, 0x64,
0x54, 0x62, 0x6c, 0x20, 0x3d, 0x20, 0x7b, 0x20, 0x30, 0x78, 0x62, 0x62, 0x2c, 0x20, 0x30, 0x78,
0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2c, 0x20,
0x30, 0x78, 0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2c, 0x20, 0x30, 0x78, 0x30, 0x30,
0x2c, 0x20, 0x30, 0x78, 0x66, 0x61, 0x2c, 0x20, 0x30, 0x78, 0x34, 0x34, 0x20, 0x7d, 0x0d, 0x0a,
0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x64, 0x61, 0x74, 0x61, 0x53, 0x74, 0x72, 0x20, 0x3d,
0x20, 0x22, 0x22, 0x0d, 0x0a, 0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20, 0xe6, 0x89, 0x93, 0xe5, 0xbc,
0x80, 0x0d, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x63, 0x74, 0x72, 0x6c, 0x5b, 0x22, 0x61, 0x63,
0x74, 0x69, 0x6f, 0x6e, 0x22, 0x5d, 0x20, 0x3d, 0x3d, 0x20, 0x31, 0x29, 0x20, 0x74, 0x68, 0x65,
0x6e, 0x0d, 0x0a, 0x09, 0x09, 0x63, 0x6d, 0x64, 0x54, 0x62, 0x6c, 0x5b, 0x32, 0x5d, 0x20, 0x3d,
0x20, 0x30, 0x78, 0x30, 0x32, 0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20, 0xe5, 0x85, 0xb3, 0xe9, 0x97,
0xad, 0x0d, 0x0a, 0x09, 0x65, 0x6c, 0x73, 0x65, 0x69, 0x66, 0x20, 0x28, 0x63, 0x74, 0x72, 0x6c,
0x5b, 0x22, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x5d, 0x20, 0x3d, 0x3d, 0x20, 0x32, 0x29,
0x20, 0x74, 0x68, 0x65, 0x6e, 0x0d, 0x0a, 0x09, 0x09, 0x63, 0x6d, 0x64, 0x54, 0x62, 0x6c, 0x5b,
0x32, 0x5d, 0x20, 0x3d, 0x20, 0x30, 0x78, 0x30, 0x31, 0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20, 0xe6,
0x9a, 0x82, 0xe5, 0x81, 0x9c, 0x0d, 0x0a, 0x09, 0x65, 0x6c, 0x73, 0x65, 0x69, 0x66, 0x20, 0x28,
0x63, 0x74, 0x72, 0x6c, 0x5b, 0x22, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x5d, 0x20, 0x3d,
0x3d, 0x20, 0x33, 0x29, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0d, 0x0a, 0x09, 0x09, 0x63, 0x6d, 0x64,
0x54, 0x62, 0x6c, 0x5b, 0x32, 0x5d, 0x20, 0x3d, 0x20, 0x30, 0x78, 0x30, 0x33, 0x0d, 0x0a, 0x09,
0x2d, 0x2d, 0x20, 0xe6, 0xb5, 0x8b, 0xe9, 0x87, 0x8f, 0x0d, 0x0a, 0x09, 0x65, 0x6c, 0x73, 0x65,
0x0d, 0x0a, 0x09, 0x09, 0x63, 0x6d, 0x64, 0x54, 0x62, 0x6c, 0x5b, 0x32, 0x5d, 0x20, 0x3d, 0x20,
0x30, 0x78, 0x30, 0x35, 0x0d, 0x0a, 0x09, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x09, 0x4c, 0x4f, 0x47,
0x54, 0x42, 0x4c, 0x28, 0x63, 0x6d, 0x64, 0x54, 0x62, 0x6c, 0x29, 0x0d, 0x0a, 0x0d, 0x0a, 0x09,
0x2d, 0x2d, 0x20, 0x75, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x6b,
0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x73, 0x74, 0x72,
0x69, 0x6e, 0x67, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75,
0x72, 0x6e, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x0d, 0x0a, 0x09, 0x64, 0x61, 0x74, 0x61, 0x53,
0x74, 0x72, 0x20, 0x3d, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x54, 0x6f, 0x53, 0x74, 0x72, 0x69,
0x6e, 0x67, 0x28, 0x63, 0x6d, 0x64, 0x54, 0x62, 0x6c, 0x29, 0x0d, 0x0a, 0x09, 0x72, 0x65, 0x74,
0x75, 0x72, 0x6e, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x6c, 0x65, 0x6e, 0x28, 0x64,
0x61, 0x74, 0x61, 0x53, 0x74, 0x72, 0x29, 0x2c, 0x20, 0x64, 0x61, 0x74, 0x61, 0x53, 0x74, 0x72,
0x0d, 0x0a, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x0d, 0x0a, 0x2d, 0x2d, 0x5b, 0x5b, 0x20, 0x4d, 0x55,
0x53, 0x54, 0x0d, 0x0a, 0x5d, 0x5d, 0x0d, 0x0a, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
0x20, 0x63, 0x76, 0x74, 0x50, 0x72, 0x69, 0x32, 0x53, 0x74, 0x64, 0x28, 0x62, 0x69, 0x6e, 0x29,
0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x64, 0x61, 0x74, 0x61, 0x54, 0x62, 0x6c,
0x20, 0x3d, 0x20, 0x7b, 0x7d, 0x0d, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x74,
0x72, 0x20, 0x3d, 0x20, 0x27, 0x7b, 0x22, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67,
0x65, 0x22, 0x3a, 0x25, 0x64, 0x7d, 0x27, 0x0d, 0x0a, 0x09, 0x64, 0x61, 0x74, 0x61, 0x54, 0x62,
0x6c, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x6f, 0x54, 0x61, 0x62, 0x6c,
0x65, 0x28, 0x62, 0x69, 0x6e, 0x29, 0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20, 0x66, 0x6f, 0x72, 0x20,
0x69, 0x20, 0x3d, 0x20, 0x31, 0x2c, 0x20, 0x23, 0x62, 0x69, 0x6e, 0x0d, 0x0a, 0x09, 0x2d, 0x2d,
0x20, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x20, 0x28, 0x62, 0x69, 0x6e, 0x5b, 0x69, 0x5d, 0x29,
0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20, 0x65, 0x6e, 0x64, 0x0d, 0x0a, 0x09, 0x4c, 0x4f, 0x47, 0x54,
0x42, 0x4c, 0x28, 0x64, 0x61, 0x74, 0x61, 0x54, 0x62, 0x6c, 0x29, 0x0d, 0x0a, 0x0d, 0x0a, 0x09,
0x73, 0x74, 0x72, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x6f, 0x72,
0x6d, 0x61, 0x74, 0x28, 0x73, 0x74, 0x72, 0x2c, 0x20, 0x31, 0x30, 0x30, 0x20, 0x2d, 0x20, 0x64,
0x61, 0x74, 0x61, 0x54, 0x62, 0x6c, 0x5b, 0x33, 0x5d, 0x29, 0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20,
0x73, 0x74, 0x72, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x6f, 0x72,
0x6d, 0x61, 0x74, 0x28, 0x73, 0x74, 0x72, 0x2c, 0x20, 0x23, 0x64, 0x61, 0x74, 0x61, 0x54, 0x62,
0x6c, 0x29, 0x0d, 0x0a, 0x09, 0x2d, 0x2d, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x20, 0x28, 0x73,
0x74, 0x72, 0x29, 0x0d, 0x0a, 0x09, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x73, 0x74, 0x72,
0x69, 0x6e, 0x67, 0x2e, 0x6c, 0x65, 0x6e, 0x28, 0x73, 0x74, 0x72, 0x29, 0x2c, 0x20, 0x73, 0x74,
0x72, 0x0d, 0x0a, 0x65, 0x6e, 0x64, 0x0d, 0x0a
    };
    const int ginScriptSize = sizeof(ginScript);

    const char beVerifiedDEV1[] = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCyQMwvQauI1/PbtQ2FwVTZwDcPcDXI1nEUIvqsz+tlmQzwpCWGUOwHbZF3AVw8b1zvF5nW/UU0aF8z2KKCqtm6gB4jSblbJZDUlvMhASiGnCUGg2lHf3MDtiMFOeGy2XmvBLDLZVP3uU8gDLfTfCqW+JWzTqoEBZrEK5IPQbi+wIDAQAB";
    const char beVerifiedDEV2[] = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRzuA57Yx2vH7z1Rp9Mz0jv8tM4yY3qnPgk0+O0EB9hhmR3f5G6wUBapbbcIV1+1rnMGrK/T/R0vh9I9SIn34O2uF/IwMAI29xUq3B7CSwyBYWOCSKl3AUGv8jVDqAhlTawni/LEU1ocjIkceBCWE1HgGpzCEAtsNyVGZKH+sHWwIDAQAB";
    const char beVerifiedDEV3[] = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC6M+LMvhAvzInKnWRjaQl7PqrpVgPgbzvZkwd+GwTwgaO+mV9kHFL6Xhor43MgiS3Q416T2JtpnHMdKRM3JTBIKkUFJPKBJO4BYnUBpsVtzuzt3vxOak8rC4GG95vb7r0ghWq6nICr54hGlkh19o/u6uohTBsZi87NZ/75Ay32kwIDAQAB";
    const char beVerifiedDEV4[] = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCWgzz4zfQCCUCEDAtBMX0TxFBwTAO51LBMoLcC86Y1SLATa+neotTsJn/kjm8i9RIMKJL52gEGzvSPJ6YNcWM0a6jDTqeOT3HFigbWHVTa09q3f64vlGbAJ5wFDJ3Mf6q2PNztJ05mtsBNC6PcvMAIIQ8YRN1bEbcCb5CyCGWVIwIDAQAB";
    const char beVerifiedSDK4[] = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCSuylVH5fmnLypsVobJEBLHtcEHldp1vUBbQXkhNGzlKo7MIWlvIdxqO2qqxIm3sffTH3EUJg034W7lJzlkP9vVGvZwEiSZXp123ZgH+nzdCJiR/CKjMGCjratPrQzwf5Elw9BWLCRhoG52lc2q0U7MWPZDEUe0FyXco+ofPKfEwIDAQAB";
    const char *remoteIP = "10.204.28.134";
    uint16_t remotePort = 5546;

    const uint8_t ginUUIDDEV1[MAX_UUID] = {"10000100011000510005"};
    const uint8_t ginSigDEV1[] = {
        0x17, 0xb9, 0xd9, 0x78, 0x06, 0x80, 0xa0, 0x49, 0x32, 0xea, 0xf2, 0x08, 0x4d, 0x7e, 0x4b, 0xb6, 
        0xcd, 0xc5, 0xcf, 0x68, 0x93, 0x84, 0x91, 0xfa, 0x6b, 0xb8, 0x90, 0xcc, 0xa1, 0x9e, 0x8d, 0x61, 
        0x53, 0x08, 0x4f, 0x67, 0x41, 0x39, 0x6c, 0x9a, 0x53, 0x3c, 0xaf, 0xa8, 0x10, 0x93, 0x67, 0x44, 
        0xb6, 0x60, 0x81, 0x05, 0xea, 0xd7, 0x2b, 0xd4, 0x8b, 0xd7, 0xb2, 0xee, 0x07, 0xa9, 0x65, 0x9c, 
        0x98, 0xc7, 0xe7, 0xd5, 0xde, 0x6e, 0xe5, 0x78, 0x9f, 0x10, 0x3e, 0xd7, 0x15, 0x7c, 0x5c, 0x16, 
        0x55, 0xe4, 0xa5, 0xf0, 0x2d, 0xe2, 0xa3, 0x4e, 0x0a, 0x6e, 0x4c, 0x8a, 0x0a, 0xa7, 0x2b, 0x51, 
        0x88, 0x96, 0x8c, 0x86, 0x4b, 0x8b, 0x73, 0x5c, 0xf1, 0xaa, 0xdf, 0xa3, 0xa3, 0xee, 0xf2, 0x98, 
        0x0a, 0x9d, 0xd9, 0xfa, 0x40, 0x29, 0x17, 0x68, 0xba, 0x2c, 0xb8, 0x02, 0x8a, 0xbf, 0xd6, 0x7d 
    };
    const uint8_t ginPubkeyDEV1Der[] =
    {
        0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 
        0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 
        0x8D, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xC2, 
        0xC9, 0x03, 0x30, 0xBD, 0x06, 0xAE, 0x23, 0x5F, 0xCF, 0x6E, 
        0xD4, 0x36, 0x17, 0x05, 0x53, 0x67, 0x00, 0xDC, 0x3D, 0xC0, 
        0xD7, 0x23, 0x59, 0xC4, 0x50, 0x8B, 0xEA, 0xB3, 0x3F, 0xAD, 
        0x96, 0x64, 0x33, 0xC2, 0x90, 0x96, 0x19, 0x43, 0xB0, 0x1D, 
        0xB6, 0x45, 0xDC, 0x05, 0x70, 0xF1, 0xBD, 0x73, 0xBC, 0x5E, 
        0x67, 0x5B, 0xF5, 0x14, 0xD1, 0xA1, 0x7C, 0xCF, 0x62, 0x8A, 
        0x0A, 0xAB, 0x66, 0xEA, 0x00, 0x78, 0x8D, 0x26, 0xE5, 0x6C, 
        0x96, 0x43, 0x52, 0x5B, 0xCC, 0x84, 0x04, 0xA2, 0x1A, 0x70, 
        0x94, 0x1A, 0x0D, 0xA5, 0x1D, 0xFD, 0xCC, 0x0E, 0xD8, 0x8C, 
        0x14, 0xE7, 0x86, 0xCB, 0x65, 0xE6, 0xBC, 0x12, 0xC3, 0x2D, 
        0x95, 0x4F, 0xDE, 0xE5, 0x3C, 0x80, 0x32, 0xDF, 0x4D, 0xF0, 
        0xAA, 0x5B, 0xE2, 0x56, 0xCD, 0x3A, 0xA8, 0x10, 0x16, 0x6B, 
        0x10, 0xAE, 0x48, 0x3D, 0x06, 0xE2, 0xFB, 0x02, 0x03, 0x01, 
        0x00, 0x01
    };

    const uint8_t ginUUIDDEV2[MAX_UUID] = {"10000100051000310024"};
    const uint8_t ginSigDEV2[] = {
        0x35, 0x86, 0x9a, 0x65, 0x15, 0x1f, 0x85, 0x1b, 0x2d, 0x8d, 0xef, 0x7a, 0x0e, 0x8f, 0x3f, 0x33, 
        0x8c, 0xd1, 0xac, 0x41, 0x3d, 0x5a, 0x55, 0xfb, 0x50, 0xb6, 0x42, 0x46, 0x4a, 0x48, 0x9a, 0xbf, 
        0x6c, 0x20, 0xb4, 0xc5, 0x89, 0xb3, 0x95, 0xad, 0x12, 0xbc, 0x13, 0x25, 0x9e, 0xa0, 0x80, 0x65, 
        0x5a, 0x78, 0x71, 0xe3, 0xf9, 0x74, 0x98, 0x4d, 0xf4, 0xcd, 0xc5, 0x03, 0xd8, 0x67, 0xbb, 0x30, 
        0x2d, 0x86, 0xf3, 0xd1, 0xbb, 0x67, 0x67, 0x9f, 0xb4, 0x28, 0xd7, 0xfd, 0x24, 0xbe, 0xc1, 0xe7, 
        0x4b, 0xfc, 0xea, 0x0c, 0x7a, 0xe6, 0x19, 0x44, 0x2c, 0xb1, 0xf7, 0xcb, 0xa6, 0x43, 0x25, 0x28, 
        0xae, 0x2d, 0xf4, 0xdc, 0x40, 0x1b, 0xec, 0xf7, 0xcb, 0xbb, 0x49, 0x29, 0xf2, 0xc8, 0x13, 0x71, 
        0x02, 0x9e, 0xa0, 0xde, 0x0b, 0x2b, 0x0d, 0xd7, 0x6b, 0xcb, 0x46, 0x46, 0x44, 0x27, 0xbf, 0x02
    };
    const uint8_t ginPubkeyDEV2Der[] =
    {
        0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 
        0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 
        0x8D, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0x91, 
        0xCE, 0xE0, 0x39, 0xED, 0x8C, 0x76, 0xBC, 0x7E, 0xF3, 0xD5, 
        0x1A, 0x7D, 0x33, 0x3D, 0x23, 0xBF, 0xCB, 0x4C, 0xE3, 0x26, 
        0x37, 0xAA, 0x73, 0xE0, 0x93, 0x4F, 0x8E, 0xD0, 0x40, 0x7D, 
        0x86, 0x19, 0x91, 0xDD, 0xFE, 0x46, 0xEB, 0x05, 0x01, 0x6A, 
        0x96, 0xDB, 0x70, 0x85, 0x75, 0xFB, 0x5A, 0xE7, 0x30, 0x6A, 
        0xCA, 0xFD, 0x3F, 0xD1, 0xD2, 0xF8, 0x7D, 0x23, 0xD4, 0x88, 
        0x9F, 0x7E, 0x0E, 0xDA, 0xE1, 0x7F, 0x23, 0x03, 0x00, 0x23, 
        0x6F, 0x71, 0x52, 0xAD, 0xC1, 0xEC, 0x24, 0xB0, 0xC8, 0x16, 
        0x16, 0x38, 0x24, 0x8A, 0x97, 0x70, 0x14, 0x1A, 0xFF, 0x23, 
        0x54, 0x3A, 0x80, 0x86, 0x54, 0xDA, 0xC2, 0x78, 0xBF, 0x2C, 
        0x45, 0x35, 0xA1, 0xC8, 0xC8, 0x91, 0xC7, 0x81, 0x09, 0x61, 
        0x35, 0x1E, 0x01, 0xA9, 0xCC, 0x21, 0x00, 0xB6, 0xC3, 0x72, 
        0x54, 0x66, 0x4A, 0x1F, 0xEB, 0x07, 0x5B, 0x02, 0x03, 0x01, 
        0x00, 0x01
    };

    const uint8_t ginUUIDDEV3[MAX_UUID] = {"10000100001000010003"};
    const uint8_t ginSigDEV3[] = {
        0x3e, 0xcf, 0xba, 0x58, 0x02, 0x8e, 0x62, 0xce, 0x77, 0xda, 0x47, 0x77, 0xfe, 0xca, 0x74, 0xbe, 
        0x04, 0x4b, 0x65, 0x42, 0x27, 0xb9, 0x70, 0xbb, 0xbc, 0x9b, 0x52, 0xe0, 0x45, 0x3d, 0x9c, 0xdc, 
        0xbd, 0xee, 0x51, 0x80, 0xfd, 0x8c, 0x75, 0xc3, 0x79, 0xbb, 0x03, 0x08, 0xa1, 0x6f, 0xe5, 0xd7, 
        0xd9, 0xb5, 0x53, 0xbd, 0x1b, 0x51, 0x22, 0x9f, 0x72, 0x27, 0xf3, 0xf6, 0x7f, 0x84, 0x38, 0x43, 
        0x06, 0xcf, 0x49, 0xb8, 0xa8, 0x8b, 0x94, 0x02, 0xb0, 0x00, 0xa2, 0x3d, 0x5a, 0x21, 0x27, 0xd5, 
        0xf5, 0xd8, 0x71, 0xe4, 0x2e, 0x51, 0x1b, 0x2f, 0x8c, 0xb2, 0xec, 0xe5, 0x14, 0xca, 0x1f, 0x96, 
        0x88, 0x6f, 0x91, 0xb4, 0xc1, 0xd3, 0x02, 0x0b, 0x0d, 0xb2, 0x71, 0x43, 0x96, 0x59, 0x51, 0xb1, 
        0xfe, 0xd4, 0xb7, 0x21, 0xeb, 0xe3, 0xb8, 0x93, 0x54, 0xc8, 0x7d, 0x48, 0x4c, 0xc3, 0xdc, 0x08
    };
    const uint8_t ginPubkeyDEV3Der[] =
    {
        0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 
        0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 
        0x8D, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xBA, 
        0x33, 0xE2, 0xCC, 0xBE, 0x10, 0x2F, 0xCC, 0x89, 0xCA, 0x9D, 
        0x64, 0x63, 0x69, 0x09, 0x7B, 0x3E, 0xAA, 0xE9, 0x56, 0x03, 
        0xE0, 0x6F, 0x3B, 0xD9, 0x93, 0x07, 0x7E, 0x1B, 0x04, 0xF0, 
        0x81, 0xA3, 0xBE, 0x99, 0x5F, 0x64, 0x1C, 0x52, 0xFA, 0x5E, 
        0x1A, 0x2B, 0xE3, 0x73, 0x20, 0x89, 0x2D, 0xD0, 0xE3, 0x5E, 
        0x93, 0xD8, 0x9B, 0x69, 0x9C, 0x73, 0x1D, 0x29, 0x13, 0x37, 
        0x25, 0x30, 0x48, 0x2A, 0x45, 0x05, 0x24, 0xF2, 0x81, 0x24, 
        0xEE, 0x01, 0x62, 0x75, 0x01, 0xA6, 0xC5, 0x6D, 0xCE, 0xEC, 
        0xED, 0xDE, 0xFC, 0x4E, 0x6A, 0x4F, 0x2B, 0x0B, 0x81, 0x86, 
        0xF7, 0x9B, 0xDB, 0xEE, 0xBD, 0x20, 0x85, 0x6A, 0xBA, 0x9C, 
        0x80, 0xAB, 0xE7, 0x88, 0x46, 0x96, 0x48, 0x75, 0xF6, 0x8F, 
        0xEE, 0xEA, 0xEA, 0x21, 0x4C, 0x1B, 0x19, 0x8B, 0xCE, 0xCD, 
        0x67, 0xFE, 0xF9, 0x03, 0x2D, 0xF6, 0x93, 0x02, 0x03, 0x01, 
        0x00, 0x01
    };

    const uint8_t ginUUIDDEV4[MAX_UUID] = {"10000100091000610006"};
    const uint8_t ginSigDEV4[] = {
        0x67, 0x19, 0x45, 0x31, 0xd6, 0x85, 0xb8, 0x68, 0x09, 0xc3, 0x76, 0x62, 0xdd, 0x79, 0x97, 0xea, 
        0x86, 0xe5, 0xf2, 0x3f, 0xc7, 0x1c, 0xdf, 0xf4, 0xc4, 0xca, 0xce, 0xce, 0xd6, 0xaa, 0xe8, 0xd9, 
        0x7e, 0xfa, 0xff, 0x6e, 0xe1, 0x28, 0xff, 0x25, 0x1d, 0x69, 0x2b, 0xa7, 0xd2, 0x24, 0x27, 0xa1, 
        0x80, 0x77, 0xb2, 0x86, 0x49, 0x07, 0xe2, 0x4d, 0x0c, 0x91, 0xd8, 0xc9, 0x06, 0x4b, 0x29, 0xb2, 
        0x00, 0xd2, 0xf2, 0x07, 0x19, 0xb8, 0x43, 0x3f, 0x91, 0x75, 0xb9, 0xfb, 0xf8, 0x05, 0x12, 0xde, 
        0x48, 0x6b, 0x2d, 0x90, 0x8c, 0xf6, 0x38, 0x9b, 0x41, 0x1e, 0x98, 0xe9, 0x45, 0x1e, 0xdd, 0x42, 
        0xd3, 0x27, 0xd8, 0xa4, 0x36, 0xdd, 0x01, 0xea, 0x98, 0x95, 0x27, 0x58, 0xb4, 0x43, 0xa6, 0x30, 
        0x9d, 0xed, 0x3b, 0x43, 0x05, 0x9c, 0xbd, 0x7d, 0x49, 0x7c, 0x23, 0xb5, 0x37, 0x26, 0x67, 0xd8
    };
    const uint8_t ginPubkeyDEV4Der[] =
    {
        0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 
        0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0x96, 0x83, 0x3c, 
        0xf8, 0xcd, 0xf4, 0x02, 0x09, 0x40, 0x84, 0x0c, 0x0b, 0x41, 0x31, 0x7d, 0x13, 0xc4, 0x50, 0x70, 
        0x4c, 0x03, 0xb9, 0xd4, 0xb0, 0x4c, 0xa0, 0xb7, 0x02, 0xf3, 0xa6, 0x35, 0x48, 0xb0, 0x13, 0x6b, 
        0xe9, 0xde, 0xa2, 0xd4, 0xec, 0x26, 0x7f, 0xe4, 0x8e, 0x6f, 0x22, 0xf5, 0x12, 0x0c, 0x28, 0x92, 
        0xf9, 0xda, 0x01, 0x06, 0xce, 0xf4, 0x8f, 0x27, 0xa6, 0x0d, 0x71, 0x63, 0x34, 0x6b, 0xa8, 0xc3, 
        0x4e, 0xa7, 0x8e, 0x4f, 0x71, 0xc5, 0x8a, 0x06, 0xd6, 0x1d, 0x54, 0xda, 0xd3, 0xda, 0xb7, 0x7f, 
        0xae, 0x2f, 0x94, 0x66, 0xc0, 0x27, 0x9c, 0x05, 0x0c, 0x9d, 0xcc, 0x7f, 0xaa, 0xb6, 0x3c, 0xdc, 
        0xed, 0x27, 0x4e, 0x66, 0xb6, 0xc0, 0x4d, 0x0b, 0xa3, 0xdc, 0xbc, 0xc0, 0x08, 0x21, 0x0f, 0x18, 
        0x44, 0xdd, 0x5b, 0x11, 0xb7, 0x02, 0x6f, 0x90, 0xb2, 0x08, 0x65, 0x95, 0x23, 0x02, 0x03, 0x01, 
        0x00, 0x01
    };

    const uint8_t ginUUIDSDK4[MAX_UUID] = {"c21efa6fa9fa4bd8ab93"};
    const uint8_t ginSigSDK4[] = {
        0x71, 0xc0, 0x8d, 0x61, 0x8f, 0x1e, 0xfb, 0x85, 0x8d, 0x0a, 0x99, 0xeb, 0x99, 0x42, 0x89, 0x53, 
        0x22, 0x38, 0x9c, 0x4b, 0xa1, 0x60, 0xb7, 0xf8, 0xe3, 0x78, 0x6b, 0x7b, 0x16, 0x00, 0x5e, 0x87, 
        0x89, 0x7f, 0x60, 0x5a, 0x13, 0x5a, 0xc7, 0x8c, 0x61, 0xbe, 0x83, 0xf1, 0xb0, 0xd5, 0xf5, 0x38, 
        0x24, 0x39, 0xd1, 0xc2, 0xe3, 0x59, 0x64, 0xa4, 0x4c, 0x42, 0x23, 0x0a, 0x1d, 0xc6, 0xd7, 0x5c, 
        0x5e, 0x07, 0x49, 0x77, 0xc6, 0xad, 0x17, 0xd1, 0x95, 0xba, 0x8b, 0x59, 0xbc, 0x30, 0xd6, 0xac, 
        0x5c, 0xa6, 0x17, 0xf5, 0x11, 0x14, 0xfb, 0xf1, 0x78, 0xe6, 0x4d, 0xf4, 0x1c, 0x92, 0xfa, 0x9c, 
        0x5b, 0x39, 0x66, 0x5f, 0xeb, 0xbe, 0xa3, 0xa2, 0x5f, 0xfc, 0x72, 0x13, 0xb4, 0xa5, 0xad, 0x2e, 
        0x84, 0xc9, 0xef, 0x4c, 0x06, 0x0b, 0xf1, 0xd7, 0x71, 0xce, 0x1e, 0x1d, 0x19, 0x15, 0xb1, 0x40
    };
    const uint8_t ginPubkeySDK4Der[] =
    {
        0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 
        0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0x92, 0xbb, 0x29, 
        0x55, 0x1f, 0x97, 0xe6, 0x9c, 0xbc, 0xa9, 0xb1, 0x5a, 0x1b, 0x24, 0x40, 0x4b, 0x1e, 0xd7, 0x04, 
        0x1e, 0x57, 0x69, 0xd6, 0xf5, 0x01, 0x6d, 0x05, 0xe4, 0x84, 0xd1, 0xb3, 0x94, 0xaa, 0x3b, 0x30, 
        0x85, 0xa5, 0xbc, 0x87, 0x71, 0xa8, 0xed, 0xaa, 0xab, 0x12, 0x26, 0xde, 0xc7, 0xdf, 0x4c, 0x7d, 
        0xc4, 0x50, 0x98, 0x34, 0xdf, 0x85, 0xbb, 0x94, 0x9c, 0xe5, 0x90, 0xff, 0x6f, 0x54, 0x6b, 0xd9, 
        0xc0, 0x48, 0x92, 0x65, 0x7a, 0x75, 0xdb, 0x76, 0x60, 0x1f, 0xe9, 0xf3, 0x74, 0x22, 0x62, 0x47, 
        0xf0, 0x8a, 0x8c, 0xc1, 0x82, 0x8e, 0xb6, 0xad, 0x3e, 0xb4, 0x33, 0xc1, 0xfe, 0x44, 0x97, 0x0f, 
        0x41, 0x58, 0xb0, 0x91, 0x86, 0x81, 0xb9, 0xda, 0x57, 0x36, 0xab, 0x45, 0x3b, 0x31, 0x63, 0xd9, 
        0x0c, 0x45, 0x1e, 0xd0, 0x5c, 0x97, 0x72, 0x8f, 0xa8, 0x7c, 0xf2, 0x9f, 0x13, 0x02, 0x03, 0x01, 
        0x00, 0x01
    };


    const char *beVerifiedDEV = beVerifiedSDK4;
    int beVerifiedDEVLen = strlen(beVerifiedSDK4);
    const uint8_t *uuid = ginUUIDSDK4;
    const uint8_t *signature = ginSigSDK4;
    int signatureLen = sizeof(ginSigSDK4);
    const uint8_t *pubkey = ginPubkeySDK4Der;
    int pubkeyLen = sizeof(ginPubkeySDK4Der);

    /*
     * AuthCfg serilization
     */
    // verify 
    ret = rsaVerify(pubkey, pubkeyLen, beVerifiedDEV, beVerifiedDEVLen, signature, signatureLen);
    APPLOG("rsaVerify [%d]\r\n", ret);
    if (0 > ret) {
        return -1;
    }

    ret = lelinkStorageInit(0x12C000, 0x3E000, 256);
    if (0 > ret) {
        return -3;
    }

    // remote ip, 10.204.28.134 is internal ip of le vpn
    strcpy(authCfg.data.remote, remoteIP);
    authCfg.data.port = remotePort;

    // uuid 
    memcpy(authCfg.data.uuid, uuid, 20);
    if (0 == halGetMac(mac, sizeof(mac))) {
        bytes2hexStr(mac, sizeof(mac), macStr, sizeof(macStr));
        memcpy(authCfg.data.uuid + 20, macStr, 12);
    }
    // pubkey
    authCfg.data.pubkeyLen = pubkeyLen;
    memcpy(authCfg.data.pubkey, pubkey, authCfg.data.pubkeyLen);

    // signature
    authCfg.data.signatureLen = signatureLen;
    memcpy(authCfg.data.signature, signature, RSA_LEN);

    if (0)
    {
        // int ret;
        // void *hdl;
        // char str[256] = {"abc"};
        // uint8_t *addr = 0x12c000;
        // uint16_t size = sizeof(AuthCfg);

        // hdl = (void *)halFlashOpen();
        // if (NULL == hdl) {
        //     return -2;
        // }
        // APPLOG("halFlashOpen ok [%d]\r\n", ret);

        // ret = halFlashErase(hdl, addr, size);
        // if (0 > ret) {
        //     return -3;
        // }
        // APPLOG("halFlashErase ok [%d]\r\n", ret);

        // authCfg.csum = crc8(&(authCfg.data), sizeof(authCfg.data));
        // {
        //     int i = 0;
        //     uint8_t *p = (uint8_t *)&authCfg;
        //     for (i = 0; i < sizeof(authCfg.data); i++) {
        //         LEPRINTF("%02x", p[i]);
        //         if (0 == (i+1) % 16) {
        //             LEPRINTF("\r\n");
        //         }
        //     }
        //     LEPRINTF("\r\n");
        // }
        // ret = halFlashWrite(hdl, &authCfg, sizeof(AuthCfg), addr);
        // if (0 > ret) {
        //     return -4;
        // }
        // APPLOG("halFlashWrite ok [%d]\r\n", ret);

        // ret = halFlashRead(hdl, &authCfg, sizeof(AuthCfg), addr);
        // if (0 > ret) {
        //     return -5;
        // }        
        // APPLOG("halFlashRead ok [%d] [%s]\r\n", ret, str);
        // // APPLOG("flashWritePrivateCfg halFlashWrite [0x%x] [0x%x][0x%x]\r\n", hdl, fr.addr, fr.size);
        // halFlashClose(hdl);
    } else {
        ret = lelinkStorageWriteAuthCfg(&authCfg);
        if (0 > ret) {
            lelinkStorageDeinit();
            return -3;
        }
    }

    /*
     * ScriptCfg serilization
     */
    // script
    ginScriptCfg.data.size = ginScriptSize;
    memcpy(ginScriptCfg.data.script, ginScript, ginScriptCfg.data.size);
    ret = lelinkStorageWriteScriptCfg(&ginScriptCfg);
    if (0 > ret) {
        lelinkStorageDeinit();
        return -4;
    }

    // test only
    if (1)
    {
        int ret = 0;
        AuthCfg authCfg2;
        char json[64] = {"{\"ctrl\":{\"pwr\":1,\"action\":2}}"};
        uint8_t buf[64] = {0};
        ret = lelinkStorageReadAuthCfg(&authCfg2);
        // {
        //     int i = 0;
        //     uint8_t *p = (uint8_t *)&authCfg2;
        //     for (i = 0; i < sizeof(authCfg2.data); i++) {
        //         LEPRINTF("%02x", p[i]);
        //         if (0 == (i+1) % 16) {
        //             LEPRINTF("\r\n");
        //         }
        //     }
        //     LEPRINTF("\r\n");
        // }
        if (authCfg2.csum != crc8(&(authCfg2.data), sizeof(authCfg2.data))) {
            APPLOG("AuthCfg not matched\n");
        } else {
            APPLOG("AuthCfg OK\n");
        }

        ret = lelinkStorageReadScriptCfg(&ginScriptCfg);
        if (ginScriptCfg.csum != crc8(&(ginScriptCfg.data), sizeof(ginScriptCfg.data))) {
            APPLOG("ScriptCfg not matched\n");
        } else {
            APPLOG("ScriptCfg OK\n");
        }

        ret = sengineCall((const char *)ginScriptCfg.data.script, ginScriptCfg.data.size, "cvtStd2Pri",
            (const uint8_t *)json, strlen(json), buf, sizeof(buf));
        APPLOG("sengineCall [%d]\r\n", ret);
    }

    lelinkStorageDeinit();
    return 0;
}
#endif
void printOutBytes(const uint8_t buf[], int len) {
    int i = 0;
    APPPRINTF("print out: [%d]\r\n", len);
    for (i = 0; i < len; i++) {
        APPPRINTF("%02x ", buf[i]);
        if ((i + 1) % 16 == 0) {
            APPPRINTF("\r\n");
        }
    }
    APPPRINTF("\n"); 
}

/*
 * Handler invoked when WLAN subsystem is ready.
 *
 * The app-framework tells the handler whether there is
 * valid network information stored in persistent memory.
 *
 * The handler can then chose to connect to the network.
 *
 * We ignore the data and just start a Micro-AP network
 * with DHCP service. This will allow a client device
 * to connect to us and receive a valid IP address via
 * DHCP.
 */
void event_wlan_init_done(void *data)
{
	int ret;
    // char utc[] = "{\"redirect\":0,\"utc\":123412341234}";
    // char tmp2[] = "{\"dir\":\"54321\"}";
    // char utc[64] = "{\"utc\":1234}";
    // syncUTC(utc, sizeof(utc));

    // memset(utc, 0, sizeof(utc));
    // memcpy(utc, tmp1, sizeof(tmp1));
    // syncUTC(utc, sizeof(utc));

    // memset(utc, 0, sizeof(utc));
    // memcpy(utc, tmp1, sizeof(tmp1));
    // syncUTC(utc, sizeof(utc));

	/*
	 * Initialize CLI Commands for some of the modules:
	 *
	 * -- wlan: allows user to explore basic wlan functions
	 */

	ret = wlan_cli_init();
	if (ret != WM_SUCCESS)
		dbg("Error: wlan_cli_init failed");

	ret = wlan_iw_cli_init();
	if (ret != WM_SUCCESS)
		dbg("Error: wlan_iw_init failed");

	/** Filter flags:
	 *		Bit[0]: Enable/disable management frame receive,
	 *		Bit[1]: Enable/disable control frame receive,
	 *		Bit[2]: Enable/disable data frame receive.
	 *
	 * radio_type:
	 *		Band configuration type
	 *		Bits[7:6]: Reserved (set to 0)
	 *		Bits[5:4]: Secondary channel offset
	 *		     00 = no secondary channel
	 *		     01 = secondary channel is above primary channel
	 *		     10 = reserved
	 *		     11 = secondary channel is below primary channel
	 *		Bits[3:2]: Channel width
	 *		     00 = 20 MHz channel width
	 *		     01, 10 and 11 = reserved
	 *		Bits[1:0]: Band information
	 *		     00 = 2.4 GHz band
	 *		     01 = 5 GHz band
	 *		     10 and 11 = reserved
	 *
	 * channel:
	 * 		Channel number in respective band.
	 *
	 * To sniff packets in 40 MHz channel bandwidth, specify secondary
	 * channel offset above/below in radio type.
	 *
	 * wlan_sniffer_start(4, 17, 40, sniffer_cb);
	 *
	 * The above call with start sniffer for data frames on channel
	 * number 40 and 44 in 5 GHz band, as secondary channel specified
	 * is above primary channel.
	 *
	 * Following call starts WLAN sniffer capturing control, management
	 * and data frames on channel 8 of 2.4 GHz band.
	 *
	 * All captured frames are delivered to registered sniffer callback
	 * sniffer_cb.
	 *
	 */

	 
    /*
    ret = wlan_sniffer_start(0x07, 0x00, 0x08, sniffer_cb);
    if (ret != WM_SUCCESS)
    dbg("Error: wlan_sniffer_start failed");
    */
    #ifdef DEBUG_AIRCONFIG
    if (0 != airconfig_start(NULL, NULL, 0))
    {
        dbg("Error: wlan_sniffer_start failed");
    }
    return;
    #endif

#if 0
    {
#include <lelink/sw/sengine.h>

        uint32_t parity = UART_PARITY_NONE;
        uint32_t stop = UART_STOPBITS_1;
        uint32_t baud = 9600;
        mdev_t  *uartPort;
        uint8_t buf[] = {0x12, 0x34, 0xab, 0xcd};
        int count = sizeof(buf) + 1;

        // extern int preGenStableInfo2Flash(void);
        // ret = preGenStableInfo2Flash();
        // APPLOG("preGenStableInfo2Flash [%d] \r\n", ret);

        #if 0
        ret = uart_drv_init(UART1_ID, UART_8BIT);
        APPLOG("uart_drv_init [%d] \r\n", ret);
        ret = uart_drv_set_opts(UART1_ID, parity, stop, UART_PARITY_NONE);
        APPLOG("uart_drv_set_opts [%d] \r\n", ret);
        uartPort = uart_drv_open(UART1_ID, baud);
        APPLOG("uart_drv_open [%d] \r\n", uartPort);
        while (count--) { // 4, 3, 2, 1
            ret = uart_drv_write(uartPort, &buf[sizeof(buf) - count], 1);
            APPLOG("uart_drv_write [%d] \r\n", ret);
            os_thread_sleep(os_msec_to_ticks(1000));
        }
        while (1) {
            int i = 0;
            ret = uart_drv_read(uartPort, buf, sizeof(buf));
            APPLOG("uart_drv_read [%d]\r\n", ret);
            if (ret > 0) {
                for (i = 0; i < ret; i++) {
                    APPPRINTF("%02x ", buf[i]);
                }
                APPPRINTF("\r\n");
            }
            os_thread_sleep(os_msec_to_ticks(1000));
        }
        #endif

        #if 1
        {
            // #define PAGE_SIZE 0x100
            #define PAGE_SIZE (0x1000)
            #define WRITE_SIZE 8*1024
            #define PIECES (WRITE_SIZE/PAGE_SIZE)
            #define START_ADDR (0x1E0000)

            mdev_t * dev = NULL;
            int ret, counts = 4;
            int pieces = PIECES, i, j;
            static uint8_t data[PAGE_SIZE] = {0};
            static uint8_t out[WRITE_SIZE] = {0};
            int tmpAddr = 0;

            while (counts--) {
                os_thread_sleep(os_msec_to_ticks(1000));
                APPLOG("waiting... [%d]\r\n", counts);
            }
            for (i = 0; i < pieces; i++) {
                int m = 0;
                tmpAddr = START_ADDR + i*PAGE_SIZE;
                for (j = 0; j < PAGE_SIZE; j++) {
                    data[m++] = j;
                }
                data[sizeof(data) - 1] = i;
                dev = (mdev_t *)flash_drv_open(FL_INT);
                ret = flash_drv_erase((mdev_t *)dev, tmpAddr, PAGE_SIZE);
                APPLOG("flash_drv_erase idx[%d][0x%x] ret[%d]\r\n", i, tmpAddr, ret);
                ret = flash_drv_write((mdev_t *)dev, data, PAGE_SIZE, tmpAddr);
                APPLOG("flash_drv_write idx[%d][0x%x] ret[%d]\r\n", i, tmpAddr, ret);
                memset(out, 0, sizeof(out));
                flash_drv_close((mdev_t *)dev);

                // os_thread_sleep(os_msec_to_ticks(100));

                dev = (mdev_t *)flash_drv_open(FL_INT);
                ret = flash_drv_read(dev, out, PAGE_SIZE, tmpAddr);
                APPLOG("flash_drv_read [0x%x] ret[%d]\r\n", tmpAddr, ret);
                if (0 == ret) {
                    ret = PAGE_SIZE;
                }
                printOutBytes(out, PAGE_SIZE); 
                flash_drv_close((mdev_t *)dev);
                APPLOG("flash_drv_close\n");
            }

            dev = (mdev_t *)flash_drv_open(FL_INT);
            memset(out, 0, sizeof(out));
            ret = flash_drv_read(dev, out, sizeof(out), START_ADDR);
            APPLOG("flash_drv_read [0x%x] ret[%d]\r\n", START_ADDR, ret);
            if (0 == ret) {
                ret = sizeof(out);
            }
            flash_drv_close((mdev_t *)dev);

            printOutBytes(out, ret); 

            APPLOG("flash pieces reading...\r\n");
            for (i = 0; i < pieces; i++) {
                tmpAddr = START_ADDR + i*PAGE_SIZE;
                dev = (mdev_t *)flash_drv_open(FL_INT);
                memset(out, 0, PAGE_SIZE);
                ret = flash_drv_read(dev, out, PAGE_SIZE, tmpAddr);
                APPLOG("flash_drv_read [0x%x] ret[%d]\r\n", tmpAddr, ret);
                if (0 == ret) {
                    ret = PAGE_SIZE;
                }
                flash_drv_close((mdev_t *)dev);

                printOutBytes(out, ret); 
            }
        }
        #endif

        return;
    }
#else
    os_dump_mem_stats();
    #ifdef PREGEN_INFO_2_FLASH
    preGenStableInfo2Flash();
    return;
    #endif

    // sector 0x1000(512pcs), block 0x10000(32pcs)
    ret = lelinkStorageInit(0x1C2000, 0x3E000, 0x1000);
    if (0 > ret) {
        APPLOGE("lelinkStorageInit ret[%d]\r\n", ret);
        return;
    }

    // protocol
    ret = lelinkInit(NULL);
    if (0 > ret) {
        return;
    }
    lelink_start();
    
    // flash
    // testFlash();

#endif
}

/* This is the main event handler for this project. The application framework
 * calls this function in response to the various events in the system.
 */
int common_event_handler(int event, void *data)
{
	switch (event) {
	case AF_EVT_WLAN_INIT_DONE:
		event_wlan_init_done(data);
		break;
    case AF_EVT_NORMAL_CONNECTING:
        // if (gin_airconfig_ap_connected == 1) {
        //     LELOGW("need to reconnect");
        //     gin_airconfig_ap_connected = -1;
        // }
        break;
    case AF_EVT_NORMAL_CONNECTED:
        gin_airconfig_ap_connected = 1;
        break;
	default:
		break;
	}

	return 0;
}

static void modules_init()
{
	int ret;

	/*
	 * Initialize wmstdio prints
	 */
	ret = wmstdio_init(UART0_ID, 0);
	if (ret != WM_SUCCESS) {
		dbg("Error: wmstdio_init failed");
		appln_critical_error_handler((void *) -WM_FAIL);
	}

	/*
	 * Initialize CLI Commands
	 */
	ret = cli_init();
	if (ret != WM_SUCCESS) {
		dbg("Error: cli_init failed");
		appln_critical_error_handler((void *) -WM_FAIL);
	}
	/* Initialize time subsystem.
	 *
	 * Initializes time to 1/1/1970 epoch 0.
	*/
    ret = wmtime_init();
    if (ret != WM_SUCCESS) {
        dbg("Error: wmtime_init failed");
        appln_critical_error_handler((void *) - WM_FAIL);
    }

    /*
    	* Register Power Management CLI Commands
    	*/
    ret = pm_cli_init();
    if (ret != WM_SUCCESS) {
        dbg("Error: pm_cli_init failed");
        appln_critical_error_handler((void *) - WM_FAIL);
    }

    /*
	 * Register Time CLI Commands
	 */
	ret = wmtime_cli_init();
	if (ret != WM_SUCCESS) {
		dbg("Error: wmtime_cli_init failed");
		appln_critical_error_handler((void *) -WM_FAIL);
	}

    ret = sysinfo_init();
    if (ret != WM_SUCCESS) {
        dbg("Error: sysinfo_init failed");
        appln_critical_error_handler((void *) -WM_FAIL);
    }

    ret = nw_utils_cli_init();
    if (ret != WM_SUCCESS) {
        dbg("Error: nw_utils_cli_init failed");
        appln_critical_error_handler((void *) -WM_FAIL);
    }
	return;
}

int main()
{
    // int count = 0;
    modules_init();

    dbg("Build Time: " __DATE__ " " __TIME__ "");
    // while (1) {
    //     count++;
    //     wmprintf("Hello World: iteration %d\r\n", count);

    //     /* Sleep  5 seconds */
    //     os_thread_sleep(os_msec_to_ticks(3000));
    // }

#if 1
	/* Start the application framework */
	if (app_framework_start(common_event_handler) != WM_SUCCESS) {
		dbg("Failed to start application framework");
				appln_critical_error_handler((void *) -WM_FAIL);
	}
#endif
	return 0;
}